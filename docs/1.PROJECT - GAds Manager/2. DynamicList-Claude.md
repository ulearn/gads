Google Ads Customer Match API Overview
In Google Ads, you'll be working with Customer Match lists (user lists). There are two main API approaches:
1. UserList Resource (for list creation/management)
resource_name: customers/{customer_id}/userLists/{user_list_id}
2. OfflineUserDataJob (for adding/removing members in bulk)
This is what you'll use most frequently - it's designed for exactly your use case.
Implementation Approach
Here's how I'd structure this with Node.js:
Step 1: Create the Customer Match List (One-time)
javascript// Using the Universal Write API
const createCustomerList = async () => {
  const operation = {
    resource_name: `customers/${customerId}/userLists`,
    create: {
      name: "SQL Pipeline Contacts",
      description: "Dynamic list of contacts in sales pipeline stages",
      membership_status: "OPEN", // Allows additions/removals
      membership_life_span: 10000, // Days members stay (max 10000)
      crm_based_user_list: {
        upload_key_type: "CONTACT_INFO", // Email and/or phone
        data_source_type: "FIRST_PARTY"
      }
    }
  };
  
  // Call GAds_Universal_Write_API with resource_type: "userLists"
};
Step 2: Add Members to the List
This is where the magic happens. You'll use OfflineUserDataJob:
javascriptconst addContactsToList = async (userListId, contacts) => {
  // contacts = [{email, phone, firstName, lastName, countryCode, postalCode}]
  
  const operations = contacts.map(contact => ({
    create: {
      user_identifiers: [
        {
          hashed_email: hashEmail(contact.email) // SHA256 hash
        },
        // Optional: add hashed phone
        contact.phone ? {
          hashed_phone_number: hashPhone(contact.phone)
        } : null
      ].filter(Boolean)
    }
  }));

  // Create offline user data job
  const job = {
    type: "CUSTOMER_MATCH_USER_LIST",
    customer_match_user_list_metadata: {
      user_list: `customers/${customerId}/userLists/${userListId}`
    },
    operations: operations
  };
};
Step 3: Remove Members (for pruning Lost contacts)
javascriptconst removeContactsFromList = async (userListId, contacts) => {
  const operations = contacts.map(contact => ({
    remove: {
      user_identifiers: [
        {
          hashed_email: hashEmail(contact.email)
        }
      ]
    }
  }));

  // Same structure as add, but with 'remove' operation
};
Your Workflow
Based on your requirements, here's the recommended flow:
Daily/Real-time Additions:
javascript// Query your MySQL sync database for new contacts in target stages
const newContacts = await db.query(`
  SELECT email, phone, first_name, last_name 
  FROM contacts 
  WHERE pipeline_stage IN ('Inbox', 'Sequenced', 'Engagement', 'Responsive', 'Advising', 'Negotiation', 'Contract')
  AND created_date >= NOW() - INTERVAL 1 DAY
`);

// Add to Google Ads list
await addContactsToList(userListId, newContacts);
Monthly Pruning:
javascript// Get Lost contacts older than 12 months
const oldLostContacts = await db.query(`
  SELECT email 
  FROM contacts 
  WHERE pipeline_stage = 'Lost'
  AND stage_updated_date < NOW() - INTERVAL 12 MONTH
`);

// Remove from Google Ads list
await removeContactsFromList(userListId, oldLostContacts);
Important Considerations

Hashing Requirements: Emails and phones MUST be SHA256 hashed and normalized (lowercase, trim whitespace)
Match Rates: Expect 30-70% match rate depending on data quality
Minimum List Size: Need 1,000+ members before Google Ads can use the list for targeting
Processing Time: Additions take 12-48 hours to populate
Rate Limits: Can process up to 500,000 members per job

My Recommendation
Go with Option B (Node.js script) because:

You avoid HubSpot marketing contact fees
Full control over the logic
You already have the MySQL sync
Can run as a cron job on your existing server
More flexible for your monthly pruning logic

Want me to help you write the actual Node.js implementation using the Google Ads MCP tools I have access to? I can show you exactly how to structure the API calls.


My RESPONSE:
So our sync time currently every day at midnight -  I could increase that in from to every hour. From there we write the js script to pull new Deals and their associated Contacts from MySql (or HubSpot directly does not really matter I guess) and push them to Google Ads 

Pruning can happen periodically via a cron (monthly / quarterly would be fine) and target the oldest deals in the list. 

Actually - perhaps there's an automatic pruning process in Google Ads based on gdpr data retention periods? I don't think you can keep advertising at contacts (even 1st part data like this) indefinitely

=============================================================

CLAUDE:

Excellent thinking! Yes, Google Ads does have automatic pruning built-in, and you're absolutely right that GDPR considerations apply here.
Google Ads Automatic Pruning
When you create a Customer Match list, you set a membership_life_span parameter:
javascriptcrm_based_user_list: {
  upload_key_type: "CONTACT_INFO",
  membership_life_span: 365  // Days until auto-removal (1-10,000)
}
How it works:

Members automatically drop off X days after they're first added
Maximum: 10,000 days (~27 years)
Typical: 180-540 days for active remarketing
This happens automatically - no manual intervention needed

Your Specific Use Case
Here's where it gets nuanced for your workflow:
Scenario:

Contact enters "Inbox" → Added to list on Day 0
Contact moves to "Lost" on Day 180 (6 months)
You want them removed 12 months after becoming Lost (Day 180 + 365 = Day 545)

Problem: If you set membership_life_span: 365, they'd drop off on Day 365, which is only 6 months after becoming Lost - not the 12 months you want.
Recommended Hybrid Approach
Set a backstop with membership_life_span, plus targeted pruning for Lost contacts:
javascript// 1. Create list with 18-month backstop
membership_life_span: 540  // 18 months - catches everything eventually

// 2. Monthly cron for Lost contact pruning
const pruneLostContacts = async () => {
  const query = `
    SELECT c.email, d.lost_reason
    FROM contacts c
    JOIN deals d ON c.id = d.contact_id
    WHERE d.pipeline_stage = 'Lost'
    AND d.stage_updated_date < DATE_SUB(NOW(), INTERVAL 12 MONTH)
    AND d.lost_reason NOT IN ('Budget - Will Return', 'Timing - Future Interest')
    -- Customize lost_reason filtering as needed
  `;
  
  const oldLost = await db.query(query);
  await removeContactsFromList(userListId, oldLost);
};
GDPR Considerations
You're right that GDPR matters here, especially for EU contacts:
Legal Basis

✅ Legitimate Interest works for remarketing to sales pipeline contacts
✅ First-party data from your CRM is generally fine
⚠️ Must respect opt-outs and unsubscribes

Best Practices

Privacy Policy: Disclose that you use Customer Match for advertising
Opt-Out Mechanism: Honor marketing opt-outs (check HubSpot unsubscribe status)
Data Minimization: Only upload what's needed (email is sufficient)
Retention Limits: Your 12-month Lost contact window is reasonable

In Your Script
javascriptconst getEligibleContacts = async () => {
  return await db.query(`
    SELECT c.email
    FROM contacts c
    JOIN deals d ON c.id = d.contact_id
    WHERE d.pipeline_stage IN ('Inbox', 'Sequenced', 'Engagement', 
                                'Responsive', 'Advising', 'Negotiation', 'Contract')
    AND c.marketing_opt_out = FALSE  -- GDPR compliance
    AND c.email_valid = TRUE
  `);
};
Recommended Implementation
Initial Setup:
javascript// Set 18-month backstop
membership_life_span: 540
Daily Sync (Hourly if you prefer):
javascript// Add new pipeline contacts
// Runs after MySQL sync completes
Monthly Cron:
javascript// Remove Lost contacts > 12 months old
// Filtered by lost_reason
Safety Net:

membership_life_span: 540 ensures nothing stays longer than 18 months
Even if your pruning script fails, contacts eventually age out

One More Thing: Re-additions
If a Lost contact re-enters the pipeline:

They can be re-added to the list
Their membership_life_span clock resets from the new addition date
This is perfect for your "Lost - Will Return" scenarios


Bottom line: Use membership_life_span: 540 as your GDPR-friendly backstop, plus monthly targeted pruning for Lost contacts. This gives you the control you want while ensuring automatic compliance with data retention best practices.
Want me to write out the complete Node.js script with all these pieces integrated?RetryN

======================================================

Me: Grand -so 12 months after entering lost -prune 

Opt-out! Yes-that important news very thought about it -myat be pulled into sync (again we may just do trips directly rather than using the MySQL sync buti kinda think "it's there-let's use it" because queries to MySQL can be a lot easier & more flexible to create

Claude: Exactly! Use what you've got - the MySQL sync is perfect for this. Queries are faster, more flexible, and you avoid HubSpot API rate limits.
Required Fields in Your MySQL Sync
Make sure your sync includes these fields:
Contacts Table:
sql- id (HubSpot contact ID)
- email
- phone (optional, for better match rates)
- first_name, last_name (optional)
- marketing_opt_out (CRITICAL for GDPR)
- email_valid / email_bounce_status
- created_date
Deals Table:
sql- id (deal ID)
- contact_id (foreign key)
- pipeline_stage ('Inbox', 'Lost', etc.)
- stage_updated_date (when they entered current stage)
- lost_reason (for filtering)
- created_date
Your Daily Sync Queries
1. Get All Active Pipeline Contacts (for additions)
sqlSELECT DISTINCT
    c.id,
    c.email,
    c.phone,
    c.first_name,
    c.last_name,
    d.pipeline_stage,
    d.stage_updated_date
FROM contacts c
INNER JOIN deals d ON c.id = d.contact_id
WHERE d.pipeline_stage IN (
    'Inbox', 'Sequenced', 'Engagement', 'Responsive', 
    'Advising', 'Negotiation', 'Contract'
)
AND c.marketing_opt_out = 0
AND c.email IS NOT NULL
AND c.email != ''
-- Optional: filter out bounced emails
AND (c.email_bounce_status IS NULL OR c.email_bounce_status != 'hard_bounce')
2. Get Recently Lost Contacts (< 12 months - keep in list)
sqlSELECT DISTINCT
    c.id,
    c.email,
    d.pipeline_stage,
    d.lost_reason,
    d.stage_updated_date,
    DATEDIFF(NOW(), d.stage_updated_date) as days_in_lost
FROM contacts c
INNER JOIN deals d ON c.id = d.contact_id
WHERE d.pipeline_stage = 'Lost'
AND d.stage_updated_date >= DATE_SUB(NOW(), INTERVAL 12 MONTH)
AND c.marketing_opt_out = 0
AND c.email IS NOT NULL
-- Optional: filter by lost_reason to exclude certain types
-- AND d.lost_reason NOT IN ('Not Interested', 'Wrong Fit')
3. Get Old Lost Contacts (> 12 months - PRUNE these)
sqlSELECT DISTINCT
    c.id,
    c.email,
    d.lost_reason,
    d.stage_updated_date,
    DATEDIFF(NOW(), d.stage_updated_date) as days_in_lost
FROM contacts c
INNER JOIN deals d ON c.id = d.contact_id
WHERE d.pipeline_stage = 'Lost'
AND d.stage_updated_date < DATE_SUB(NOW(), INTERVAL 12 MONTH)
-- These get removed from Google Ads list
4. Get Newly Opted-Out Contacts (for immediate removal)
sqlSELECT DISTINCT
    c.id,
    c.email,
    c.marketing_opt_out_date
FROM contacts c
WHERE c.marketing_opt_out = 1
AND c.marketing_opt_out_date >= DATE_SUB(NOW(), INTERVAL 1 DAY)
-- Remove these immediately from Google Ads
Node.js Workflow Structure
javascript// config.js
const GOOGLE_ADS_USER_LIST_ID = '12345678';
const SYNC_FREQUENCY = '0 */1 * * *'; // Hourly
const PRUNE_FREQUENCY = '0 0 1 * *';  // Monthly (1st day)

// main.js
const hourlySync = async () => {
  console.log('Starting hourly sync...');
  
  // 1. Get all contacts that SHOULD be in the list
  const activeContacts = await getActiveContacts();
  const recentLostContacts = await getRecentLostContacts();
  const allEligibleContacts = [...activeContacts, ...recentLostContacts];
  
  // 2. Add them (Google Ads handles deduplication)
  await addContactsToGoogleAds(GOOGLE_ADS_USER_LIST_ID, allEligibleContacts);
  
  // 3. Handle opt-outs (immediate removal)
  const newOptOuts = await getNewOptOuts();
  if (newOptOuts.length > 0) {
    await removeContactsFromGoogleAds(GOOGLE_ADS_USER_LIST_ID, newOptOuts);
  }
  
  console.log(`Added ${allEligibleContacts.length} contacts, removed ${newOptOuts.length} opt-outs`);
};

const monthlyPrune = async () => {
  console.log('Starting monthly prune...');
  
  // Get Lost contacts older than 12 months
  const oldLostContacts = await getOldLostContacts();
  
  await removeContactsFromGoogleAds(GOOGLE_ADS_USER_LIST_ID, oldLostContacts);
  
  console.log(`Pruned ${oldLostContacts.length} old Lost contacts`);
};
Why MySQL > Direct API Calls
FactorMySQL SyncHubSpot APISpeedInstant100ms+ per callFlexibilityComplex JOINs, date mathLimited filteringRate LimitsNone100 calls/10 secComplexitySingle queryMultiple paginated callsCostFree (you have it)Potential timeout issues
Plus: You can test/debug queries instantly in MySQL Workbench or command line without hitting any APIs.
One Important Detail: Deduplication
Google Ads automatically deduplicates by hashed email, so you can safely:

Add the same contact multiple times (it just updates their membership date)
Not worry about "is this contact already in the list?"

This means your hourly sync can just push all eligible contacts every time - super simple!
Next Steps

Verify your MySQL sync includes marketing_opt_out field
Test the queries above on your database
Want me to write the complete Node.js script with Google Ads API integration using the MCP tools I have access to?