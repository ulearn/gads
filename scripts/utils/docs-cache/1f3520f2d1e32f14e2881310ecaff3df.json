{
  "url": "https://developers.google.com/google-ads/api/docs/remarketing/audience-segments/customer-match/get-started",
  "title": "Get started with Customer Match  |  Google Ads API  |  Google for DevelopersGoogleGoogle",
  "headings": [
    {
      "level": "h1",
      "text": "Get started with Customer Match\n\n    \n    \n      \n    \n\n    \n      \n      Stay organized with collections\n    \n    \n      \n      Save and categorize content based on your preferences."
    },
    {
      "level": "h2",
      "text": "AI-generated Key Takeaways"
    },
    {
      "level": "h2",
      "text": "Prerequisites"
    },
    {
      "level": "h2",
      "text": "Before you start: Plan your implementation"
    },
    {
      "level": "h3",
      "text": "Usage flow"
    },
    {
      "level": "h3",
      "text": "OfflineUserDataJobService and UserDataService"
    },
    {
      "level": "h3",
      "text": "Best practices"
    },
    {
      "level": "h2",
      "text": "Step 1: Create a customer list"
    },
    {
      "level": "h4",
      "text": "Code example to create a customer list"
    },
    {
      "level": "h3",
      "text": "Java"
    },
    {
      "level": "h3",
      "text": "C#"
    },
    {
      "level": "h3",
      "text": "PHP"
    },
    {
      "level": "h3",
      "text": "Python"
    },
    {
      "level": "h3",
      "text": "Ruby"
    },
    {
      "level": "h3",
      "text": "Perl"
    },
    {
      "level": "h2",
      "text": "Step 2: Add members to the user list"
    },
    {
      "level": "h4",
      "text": "Upload user contact information"
    },
    {
      "level": "h4",
      "text": "Upload CRM IDs"
    },
    {
      "level": "h4",
      "text": "Upload mobile IDs"
    },
    {
      "level": "h4",
      "text": "Code example"
    },
    {
      "level": "h3",
      "text": "Java"
    },
    {
      "level": "h3",
      "text": "C#"
    },
    {
      "level": "h3",
      "text": "PHP"
    },
    {
      "level": "h3",
      "text": "Python"
    },
    {
      "level": "h3",
      "text": "Ruby"
    },
    {
      "level": "h3",
      "text": "Perl"
    },
    {
      "level": "h2",
      "text": "Step 3: Verify list upload and match rate"
    },
    {
      "level": "h4",
      "text": "Code example to check job status"
    },
    {
      "level": "h3",
      "text": "Java"
    },
    {
      "level": "h3",
      "text": "C#"
    },
    {
      "level": "h3",
      "text": "PHP"
    },
    {
      "level": "h3",
      "text": "Python"
    },
    {
      "level": "h3",
      "text": "Ruby"
    },
    {
      "level": "h3",
      "text": "Perl"
    },
    {
      "level": "h4",
      "text": "Code example to query the user_list resource"
    },
    {
      "level": "h3",
      "text": "Java"
    },
    {
      "level": "h3",
      "text": "C#"
    },
    {
      "level": "h3",
      "text": "PHP"
    },
    {
      "level": "h3",
      "text": "Python"
    },
    {
      "level": "h3",
      "text": "Ruby"
    },
    {
      "level": "h3",
      "text": "Perl"
    },
    {
      "level": "h3",
      "text": "Compare to the Google Ads UI"
    },
    {
      "level": "h2",
      "text": "Step 4: Target your list"
    },
    {
      "level": "h4",
      "text": "Code example to target ads in ad group to a user list"
    },
    {
      "level": "h3",
      "text": "Java"
    },
    {
      "level": "h3",
      "text": "C#"
    },
    {
      "level": "h3",
      "text": "PHP"
    },
    {
      "level": "h3",
      "text": "Python"
    },
    {
      "level": "h3",
      "text": "Ruby"
    },
    {
      "level": "h3",
      "text": "Perl"
    },
    {
      "level": "h3",
      "text": "Target multiple customer lists"
    },
    {
      "level": "h2",
      "text": "Manage and update your lists"
    }
  ],
  "codeBlocks": [
    "OfflineUserDataJob",
    "logical_user_list",
    "OfflineUserDataJob",
    "customer_match_user_list_metadata",
    "OfflineUserDataJob",
    "OfflineUserDataJobError.CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS",
    "consent.ad_user_data",
    "consent.ad_personalization",
    "customer_match_user_list_metadata",
    "OfflineUserDataJobService.AddOfflineUserDataJobOperations",
    "AddOfflineUserDataJobOperations",
    "UserIdentifier",
    "hashed_email",
    "UserIdentifier",
    "hashed_phone_number",
    "UserIdentifier",
    "UserIdentifier",
    "OfflineUserDataJobService",
    "UserDataService",
    "user_identifiers",
    "customer_match_user_list_metadata",
    "UploadUserDataRequest",
    "received_operations_count",
    "consent.ad_user_data",
    "consent.ad_personalization",
    "UploadUserDataRequest",
    "UserDataService",
    "OfflineUserDataJobService",
    "AddOfflineUserDataJobOperationsRequest",
    "RESOURCE_EXHAUSTED",
    "OfflineUserDataJob",
    "CONFLICTING_OPERATION",
    "partial_failure",
    "AddOfflineUserDataJobOperationsRequest",
    "OfflineUserDataJob",
    "OfflineUserDataJob",
    "CustomerMatchUserListMetadata.user_list",
    "CONCURRENT_MODIFICATION",
    "OfflineUserDataJob",
    "UserListService",
    "crm_based_user_list",
    "crm_based_user_list",
    "crm_based_user_list",
    "CrmBasedUserList",
    "upload_key_type",
    "CONTACT_INFO",
    "MOBILE_ADVERTISING_ID",
    "data_source_type",
    "FIRST_PARTY",
    "membership_life_span",
    "membership_life_span",
    "membership_status",
    "private String createCustomerMatchUserList(GoogleAdsClient googleAdsClient, long customerId) {\n  // Creates the new user list.\n  UserList userList =\n      UserList.newBuilder()\n          .setName(\"Customer Match list #\" + getPrintableDateTime())\n          .setDescription(\"A list of customers that originated from email addresses\")\n          // Membership life span must be between 0 and 540 days inclusive. See:\n          // https://developers.google.com/google-ads/api/reference/rpc/latest/UserList#membership_life_span\n          // Sets the membership life span to 30 days.\n          .setMembershipLifeSpan(30)\n          // Sets the upload key type to indicate the type of identifier that will be used to\n          // add users to the list. This field is immutable and required for a CREATE operation.\n          .setCrmBasedUserList(\n              CrmBasedUserListInfo.newBuilder()\n                  .setUploadKeyType(CustomerMatchUploadKeyType.CONTACT_INFO))\n          .build();\n\n  // Creates the operation.\n  UserListOperation operation = UserListOperation.newBuilder().setCreate(userList).build();\n\n  // Creates the service client.\n  try (UserListServiceClient userListServiceClient =\n      googleAdsClient.getLatestVersion().createUserListServiceClient()) {\n    // Adds the user list.\n    MutateUserListsResponse response =\n        userListServiceClient.mutateUserLists(\n            Long.toString(customerId), ImmutableList.of(operation));\n    // Prints the response.\n    System.out.printf(\n        \"Created Customer Match user list with resource name: %s.%n\",\n        response.getResults(0).getResourceName());\n    return response.getResults(0).getResourceName();\n  }\n}\nAddCustomerMatchUserList.java",
    "private string CreateCustomerMatchUserList(GoogleAdsClient client, long customerId)\n{\n    // Get the UserListService.\n    UserListServiceClient service = client.GetService(Services.V22.UserListService);\n\n    // Creates the user list.\n    UserList userList = new UserList()\n    {\n        Name = $\"Customer Match list# {ExampleUtilities.GetShortRandomString()}\",\n        Description = \"A list of customers that originated from email and physical\" +\n            \" addresses\",\n        // Membership life span must be between 0 and 540 days inclusive. See:\n        // https://developers.google.com/google-ads/api/reference/rpc/latest/UserList#membership_life_span\n        // Sets the membership life span to 30 days.\n        MembershipLifeSpan = 30,\n        CrmBasedUserList = new CrmBasedUserListInfo()\n        {\n            UploadKeyType = CustomerMatchUploadKeyType.ContactInfo\n        }\n    };\n    // Creates the user list operation.\n    UserListOperation operation = new UserListOperation()\n    {\n        Create = userList\n    };\n\n    // Issues a mutate request to add the user list and prints some information.\n    MutateUserListsResponse response = service.MutateUserLists(\n        customerId.ToString(), new[] { operation });\n    string userListResourceName = response.Results[0].ResourceName;\n    Console.WriteLine($\"User list with resource name '{userListResourceName}' \" +\n        $\"was created.\");\n    return userListResourceName;\n}AddCustomerMatchUserList.cs",
    "private static function createCustomerMatchUserList(\n    GoogleAdsClient $googleAdsClient,\n    int $customerId\n): string {\n    // Creates the user list.\n    $userList = new UserList([\n        'name' => 'Customer Match list #' . Helper::getPrintableDatetime(),\n        'description' => 'A list of customers that originated from email '\n            . 'and physical addresses',\n        // Membership life span must be between 0 and 540 days inclusive. See:\n        // https://developers.google.com/google-ads/api/reference/rpc/latest/UserList#membership_life_span\n        // Sets the membership life span to 30 days.\n        'membership_life_span' => 30,\n        'crm_based_user_list' => new CrmBasedUserListInfo([\n            // Sets the upload key type to indicate the type of identifier that will be used to\n            // add users to the list. This field is immutable and required for a CREATE\n            // operation.\n            'upload_key_type' => CustomerMatchUploadKeyType::CONTACT_INFO\n        ])\n    ]);\n\n    // Creates the user list operation.\n    $operation = new UserListOperation();\n    $operation->setCreate($userList);\n\n    // Issues a mutate request to add the user list and prints some information.\n    $userListServiceClient = $googleAdsClient->getUserListServiceClient();\n    $response = $userListServiceClient->mutateUserLists(\n        MutateUserListsRequest::build($customerId, [$operation])\n    );\n    $userListResourceName = $response->getResults()[0]->getResourceName();\n    printf(\"User list with resource name '%s' was created.%s\", $userListResourceName, PHP_EOL);\n\n    return $userListResourceName;\n}AddCustomerMatchUserList.php",
    "def create_customer_match_user_list(\n    client: GoogleAdsClient, customer_id: str\n) -> str:\n    \"\"\"Creates a Customer Match user list.\n\n    Args:\n        client: The Google Ads client.\n        customer_id: The ID for the customer that owns the user list.\n\n    Returns:\n        The string resource name of the newly created user list.\n    \"\"\"\n    # Creates the UserListService client.\n    user_list_service_client: UserListServiceClient = client.get_service(\n        \"UserListService\"\n    )\n\n    # Creates the user list operation.\n    user_list_operation: UserListOperation = client.get_type(\n        \"UserListOperation\"\n    )\n\n    # Creates the new user list.\n    user_list: UserList = user_list_operation.create\n    user_list.name = f\"Customer Match list #{uuid.uuid4()}\"\n    user_list.description = (\n        \"A list of customers that originated from email and physical addresses\"\n    )\n    # Sets the upload key type to indicate the type of identifier that is used\n    # to add users to the list. This field is immutable and required for a\n    # CREATE operation.\n    user_list.crm_based_user_list.upload_key_type = (\n        client.enums.CustomerMatchUploadKeyTypeEnum.CONTACT_INFO\n    )\n    # Membership life span must be between 0 and 540 days inclusive. See:\n    # https://developers.google.com/google-ads/api/reference/rpc/latest/UserList#membership_life_span\n    # Sets the membership life span to 30 days.\n    user_list.membership_life_span = 30\n\n    response: MutateUserListsResponse = (\n        user_list_service_client.mutate_user_lists(\n            customer_id=customer_id, operations=[user_list_operation]\n        )\n    )\n    user_list_resource_name: str = response.results[0].resource_name\n    print(\n        f\"User list with resource name '{user_list_resource_name}' was created.\"\n    )\n\n    return user_list_resource_nameadd_customer_match_user_list.py",
    "def create_customer_match_user_list(client, customer_id)\n  # Creates the user list.\n  operation = client.operation.create_resource.user_list do |ul|\n    ul.name = \"Customer Match List #{(Time.new.to_f * 1000).to_i}\"\n    ul.description = \"A list of customers that originated from email and \" \\\n      \"physical addresses\"\n    # Membership life span must be between 0 and 540 days inclusive. See:\n    # https://developers.google.com/google-ads/api/reference/rpc/latest/UserList#membership_life_span\n    # Sets the membership life span to 30 days.\n    ul.membership_life_span = 30\n    ul.crm_based_user_list = client.resource.crm_based_user_list_info do |crm|\n      crm.upload_key_type = :CONTACT_INFO\n    end\n  end\n\n  # Issues a mutate request to add the user list and prints some information.\n  response = client.service.user_list.mutate_user_lists(\n    customer_id: customer_id,\n    operations: [operation],\n  )\n\n  # Prints out some information about the newly created user list.\n  resource_name = response.results.first.resource_name\n  puts \"User list with resource name #{resource_name} was created.\"\n\n  resource_name\nendadd_customer_match_user_list.rb",
    "sub create_customer_match_user_list {\n  my ($api_client, $customer_id) = @_;\n\n  # Create the user list.\n  my $user_list = Google::Ads::GoogleAds::V22::Resources::UserList->new({\n      name        => \"Customer Match list #\" . uniqid(),\n      description =>\n        \"A list of customers that originated from email and physical addresses\",\n      # Membership life span must be between 0 and 540 days inclusive. See:\n      # https://developers.google.com/google-ads/api/reference/rpc/latest/UserList#membership_life_span\n      # Set the membership life span to 30 days.\n      membershipLifeSpan => 30,\n      # Set the upload key type to indicate the type of identifier that will be\n      # used to add users to the list. This field is immutable and required for\n      # a CREATE operation.\n      crmBasedUserList =>\n        Google::Ads::GoogleAds::V22::Common::CrmBasedUserListInfo->new({\n          uploadKeyType => CONTACT_INFO\n        })});\n\n  # Create the user list operation.\n  my $user_list_operation =\n    Google::Ads::GoogleAds::V22::Services::UserListService::UserListOperation->\n    new({\n      create => $user_list\n    });\n\n  # Issue a mutate request to add the user list and print some information.\n  my $user_lists_response = $api_client->UserListService()->mutate({\n      customerId => $customer_id,\n      operations => [$user_list_operation]});\n  my $user_list_resource_name =\n    $user_lists_response->{results}[0]{resourceName};\n  printf \"User list with resource name '%s' was created.\\n\",\n    $user_list_resource_name;\n\n  return $user_list_resource_name;\n}add_customer_match_user_list.pl",
    "CrmBasedUserListInfo.upload_key_type",
    "UserIdentifier",
    "TOO_MANY_USER_IDENTIFIERS",
    "upload_key_type",
    "CONTACT_INFO",
    "+12125650000",
    "+442070313000",
    "googlemail.com",
    "upload_key_type",
    "upload_key_type",
    "CONTACT_INFO",
    "upload_key_type",
    "MOBILE_ADVERTISING_ID",
    "third_party_user_id",
    "UserIdentifier",
    "upload_key_type",
    "MOBILE_ADVERTISING_ID",
    "OfflineUserDataJobOperation",
    "// Creates a raw input list of unhashed user information, where each element of the list\n// represents a single user and is a map containing a separate entry for the keys \"email\",\n// \"phone\", \"firstName\", \"lastName\", \"countryCode\", and \"postalCode\". In your application, this\n// data might come from a file or a database.\nList<Map<String, String>> rawRecords = new ArrayList<>();\n// The first user data has an email address and a phone number.\nMap<String, String> rawRecord1 =\n    ImmutableMap.<String, String>builder()\n        .put(\"email\", \"dana@example.com\")\n        // Phone number to be converted to E.164 format, with a leading '+' as required. This\n        // includes whitespace that will be removed later.\n        .put(\"phone\", \"+1 800 5550101\")\n        .build();\n// The second user data has an email address, a mailing address, and a phone number.\nMap<String, String> rawRecord2 =\n    ImmutableMap.<String, String>builder()\n        // Email address that includes a period (.) before the domain.\n        .put(\"email\", \"alex.2@example.com\")\n        // Address that includes all four required elements: first name, last name, country\n        // code, and postal code.\n        .put(\"firstName\", \"Alex\")\n        .put(\"lastName\", \"Quinn\")\n        .put(\"countryCode\", \"US\")\n        .put(\"postalCode\", \"94045\")\n        // Phone number to be converted to E.164 format, with a leading '+' as required.\n        .put(\"phone\", \"+1 800 5550102\")\n        .build();\n// The third user data only has an email address.\nMap<String, String> rawRecord3 =\n    ImmutableMap.<String, String>builder().put(\"email\", \"charlie@example.com\").build();\n// Adds the raw records to the raw input list.\nrawRecords.add(rawRecord1);\nrawRecords.add(rawRecord2);\nrawRecords.add(rawRecord3);\n\n// Iterates over the raw input list and creates a UserData object for each record.\nList<UserData> userDataList = new ArrayList<>();\nfor (Map<String, String> rawRecord : rawRecords) {\n  // Creates a builder for the UserData object that represents a member of the user list.\n  UserData.Builder userDataBuilder = UserData.newBuilder();\n  // Checks if the record has email, phone, or address information, and adds a SEPARATE\n  // UserIdentifier object for each one found. For example, a record with an email address and a\n  // phone number will result in a UserData with two UserIdentifiers.\n\n  // IMPORTANT: Since the identifier attribute of UserIdentifier\n  // (https://developers.google.com/google-ads/api/reference/rpc/latest/UserIdentifier) is a\n  // oneof\n  // (https://protobuf.dev/programming-guides/proto3/#oneof-features), you must set only ONE of\n  // hashedEmail, hashedPhoneNumber, mobileId, thirdPartyUserId, or addressInfo. Setting more\n  // than one of these attributes on the same UserIdentifier will clear all the other members\n  // of the oneof. For example, the following code is INCORRECT and will result in a\n  // UserIdentifier with ONLY a hashedPhoneNumber.\n  //\n  // UserIdentifier incorrectlyPopulatedUserIdentifier =\n  //     UserIdentifier.newBuilder()\n  //         .setHashedEmail(\"...\")\n  //         .setHashedPhoneNumber(\"...\")\n  //         .build();\n  //\n  // The separate 'if' statements below demonstrate the correct approach for creating a UserData\n  // for a member with multiple UserIdentifiers.\n\n  // Checks if the record has an email address, and if so, adds a UserIdentifier for it.\n  if (rawRecord.containsKey(\"email\")) {\n    UserIdentifier hashedEmailIdentifier =\n        UserIdentifier.newBuilder()\n            .setHashedEmail(normalizeAndHash(sha256Digest, rawRecord.get(\"email\"), true))\n            .build();\n    // Adds the hashed email identifier to the UserData object's list.\n    userDataBuilder.addUserIdentifiers(hashedEmailIdentifier);\n  }\n\n  // Checks if the record has a phone number, and if so, adds a UserIdentifier for it.\n  if (rawRecord.containsKey(\"phone\")) {\n    UserIdentifier hashedPhoneNumberIdentifier =\n        UserIdentifier.newBuilder()\n            .setHashedPhoneNumber(normalizeAndHash(sha256Digest, rawRecord.get(\"phone\"), true))\n            .build();\n    // Adds the hashed phone number identifier to the UserData object's list.\n    userDataBuilder.addUserIdentifiers(hashedPhoneNumberIdentifier);\n  }\n\n  // Checks if the record has all the required mailing address elements, and if so, adds a\n  // UserIdentifier for the mailing address.\n  if (rawRecord.containsKey(\"firstName\")) {\n    // Checks if the record contains all the other required elements of a mailing address.\n    Set<String> missingAddressKeys = new HashSet<>();\n    for (String addressKey : new String[] {\"lastName\", \"countryCode\", \"postalCode\"}) {\n      if (!rawRecord.containsKey(addressKey)) {\n        missingAddressKeys.add(addressKey);\n      }\n    }\n\n    if (!missingAddressKeys.isEmpty()) {\n      System.out.printf(\n          \"Skipping addition of mailing address information because the following required keys\"\n              + \" are missing: %s%n\",\n          missingAddressKeys);\n    } else {\n      // Creates an OfflineUserAddressInfo object that contains all the required elements of a\n      // mailing address.\n      OfflineUserAddressInfo addressInfo =\n          OfflineUserAddressInfo.newBuilder()\n              .setHashedFirstName(\n                  normalizeAndHash(sha256Digest, rawRecord.get(\"firstName\"), false))\n              .setHashedLastName(\n                  normalizeAndHash(sha256Digest, rawRecord.get(\"lastName\"), false))\n              .setCountryCode(rawRecord.get(\"countryCode\"))\n              .setPostalCode(rawRecord.get(\"postalCode\"))\n              .build();\n      UserIdentifier addressIdentifier =\n          UserIdentifier.newBuilder().setAddressInfo(addressInfo).build();\n      // Adds the address identifier to the UserData object's list.\n      userDataBuilder.addUserIdentifiers(addressIdentifier);\n    }\n  }\n\n  if (!userDataBuilder.getUserIdentifiersList().isEmpty()) {\n    // Builds the UserData and adds it to the list.\n    userDataList.add(userDataBuilder.build());\n  }\n}\n\n// Creates the operations to add users.\nList<OfflineUserDataJobOperation> operations = new ArrayList<>();\nfor (UserData userData : userDataList) {\n  operations.add(OfflineUserDataJobOperation.newBuilder().setCreate(userData).build());\n}AddCustomerMatchUserList.java",
    "// Creates a raw input list of unhashed user information, where each element of the list\n// represents a single user and is a map containing a separate entry for the keys\n// \"email\", \"phone\", \"firstName\", \"lastName\", \"countryCode\", and \"postalCode\".\n// In your application, this data might come from a file or a database.\nList<Dictionary<string, string>> rawRecords = new List<Dictionary<string, string>>();\n\n// The first user data has an email address and a phone number.\nDictionary<string, string> rawRecord1 = new Dictionary<string, string>();\nrawRecord1.Add(\"email\", \"dana@example.com\");\n// Phone number to be converted to E.164 format, with a leading '+' as required.\n// This includes whitespace that will be removed later.\nrawRecord1.Add(\"phone\", \"+1 800 5550101\");\n\n// The second user data has an email address, a mailing address, and a phone number.\nDictionary<string, string> rawRecord2 = new Dictionary<string, string>();\n// Email address that includes a period (.) before the Gmail domain.\nrawRecord2.Add(\"email\", \"alex.2@example.com\");\n// Address that includes all four required elements: first name, last name, country\n// code, and postal code.\nrawRecord2.Add(\"firstName\", \"Alex\");\nrawRecord2.Add(\"lastName\", \"Quinn\");\nrawRecord2.Add(\"countryCode\", \"US\");\nrawRecord2.Add(\"postalCode\", \"94045\");\n// Phone number to be converted to E.164 format, with a leading '+' as required.\n// This includes whitespace that will be removed later.\nrawRecord2.Add(\"phone\", \"+1 800 5550102\");\n\n// The third user data only has an email address.\nDictionary<string, string> rawRecord3 = new Dictionary<string, string>();\nrawRecord3.Add(\"email\", \"charlie@example.com\");\n\n// Adds the raw records to the raw input list.\nrawRecords.Add(rawRecord1);\nrawRecords.Add(rawRecord2);\nrawRecords.Add(rawRecord3);\n\n// Iterates over the raw input list and creates a UserData object for each record.\nList<UserData> userDataList = new List<UserData>();\nforeach (Dictionary<string, string> rawRecord in rawRecords) {\n    // Creates a UserData object that represents a member of the user list.\n    UserData userData = new UserData();\n    // Checks if the record has email, phone, or address information, and adds a\n    // SEPARATE UserIdentifier object for each one found.\n    // For example, a record with an email address and a phone number will result in a\n    // UserData with two UserIdentifiers.\n\n    // IMPORTANT: Since the identifier attribute of UserIdentifier\n    // (https://developers.google.com/google-ads/api/reference/rpc/latest/UserIdentifier)\n    // is a oneof\n    // (https://protobuf.dev/programming-guides/proto3/#oneof-features), you must set\n    // only ONE of hashedEmail, hashedPhoneNumber, mobileId, thirdPartyUserId,\n    // or addressInfo.\n    // Setting more than one of these attributes on the same UserIdentifier will clear\n    // all the other members of the oneof.\n    // For example, the following code is INCORRECT and will result in a UserIdentifier\n    // with ONLY a hashedPhoneNumber.\n    //\n    // UserIdentifier incorrectlyPopulatedUserIdentifier = new UserIdentifier()\n    // {\n    //      HashedEmail = \"...\",\n    //      HashedPhoneNumber = \"...\"\n    // };\n    //\n    // The separate 'if' statements below demonstrate the correct approach for creating\n    // a UserData for a member with multiple UserIdentifiers.\n\n    // Checks if the record has an email address, and if so, adds a UserIdentifier\n    // for it.\n    if (rawRecord.ContainsKey(\"email\")) {\n        UserIdentifier hashedEmailIdentifier = new UserIdentifier()\n        {\n            HashedEmail = NormalizeAndHash(rawRecord[\"email\"], true)\n        };\n\n        userData.UserIdentifiers.Add(hashedEmailIdentifier);\n    }\n\n    // Checks if the record has a phone number, and if so, adds a UserIdentifier for it.\n    if (rawRecord.ContainsKey(\"phone\")) {\n        UserIdentifier hashedPhoneNumberIdentifier = new UserIdentifier()\n        {\n            HashedPhoneNumber = NormalizeAndHash(rawRecord[\"phone\"], true)\n        };\n\n        // Adds the hashed phone number identifier to the UserData object's list.\n        userData.UserIdentifiers.Add(hashedPhoneNumberIdentifier);\n    }\n\n    // Checks if the record has all the required mailing address elements, and if so,\n    // adds a UserIdentifier for the mailing address.\n    if (rawRecord.ContainsKey(\"firstName\")) {\n        // Checks if the record contains all the other required elements of a mailing\n        // address.\n        HashSet<string> missingAddressKeys = new HashSet<string>();\n        foreach (string addressKey in new string[] {\"lastName\", \"countryCode\",\n            \"postalCode\"}) {\n        if (!rawRecord.ContainsKey(addressKey)) {\n            missingAddressKeys.Add(addressKey);\n        }\n        }\n\n        if (!missingAddressKeys.Any()) {\n        Console.WriteLine(\n            $\"Skipping addition of mailing address information because the following \" +\n                \"required keys are missing: {missingAddressKeys}\");\n        } else {\n            // Creates an OfflineUserAddressInfo object that contains all the required\n            // elements of a mailing address.\n            OfflineUserAddressInfo addressInfo = new OfflineUserAddressInfo()\n            {\n                HashedFirstName = NormalizeAndHash(rawRecord[\"firstName\"]),\n                HashedLastName = NormalizeAndHash(rawRecord[\"lastName\"]),\n                CountryCode = rawRecord[\"countryCode\"],\n                PostalCode = rawRecord[\"postalCode\"]\n            };\n\n            UserIdentifier addressIdentifier = new UserIdentifier()\n            {\n                AddressInfo = addressInfo\n            };\n\n            // Adds the address identifier to the UserData object's list.\n            userData.UserIdentifiers.Add(addressIdentifier);\n        }\n    }\n\n    if (userData.UserIdentifiers.Any())\n    {\n        userDataList.Add(userData);\n    }\n}\n\n// Creates the operations to add the users.\nList<OfflineUserDataJobOperation> operations = new List<OfflineUserDataJobOperation>();\nforeach(UserData userData in userDataList)\n{\n    operations.Add(new OfflineUserDataJobOperation()\n    {\n        Create = userData\n    });\n}AddCustomerMatchUserList.cs",
    "// Creates a raw input list of unhashed user information, where each element of the list\n// represents a single user and is a map containing a separate entry for the keys 'email',\n// 'phone', 'firstName', 'lastName', 'countryCode', and 'postalCode'. In your application,\n// this data might come from a file or a database.\n$rawRecords = [];\n// The first user data has an email address and a phone number.\n$rawRecord1 = [\n    // The first user data has an email address and a phone number.\n    'email' => 'dana@example.com',\n    // Phone number to be converted to E.164 format, with a leading '+' as required. This\n    // includes whitespace that will be removed later.\n    'phone' => '+1 800 5550101'\n];\n$rawRecords[] = $rawRecord1;\n\n// The second user data has an email address, a mailing address, and a phone number.\n$rawRecord2 = [\n    // Email address that includes a period (.) before the Gmail domain.\n    'email' => 'alex.2@example.com',\n    // Address that includes all four required elements: first name, last name, country\n    // code, and postal code.\n    'firstName' => 'Alex',\n    'lastName' => 'Quinn',\n    'countryCode' => 'US',\n    'postalCode' => '94045',\n    // Phone number to be converted to E.164 format, with a leading '+' as required.\n    'phone' => '+1 800 5550102',\n];\n$rawRecords[] = $rawRecord2;\n\n// The third user data only has an email address.\n$rawRecord3 = ['email' => 'charlie@example.com'];\n$rawRecords[] = $rawRecord3;\n\n// Iterates over the raw input list and creates a UserData object for each record.\n$userDataList = [];\nforeach ($rawRecords as $rawRecord) {\n    // Checks if the record has email, phone, or address information, and adds a SEPARATE\n    // UserIdentifier object for each one found. For example, a record with an email address\n    // and a phone number will result in a UserData with two UserIdentifiers.\n\n    // IMPORTANT: Since the identifier attribute of UserIdentifier\n    // (https://developers.google.com/google-ads/api/reference/rpc/latest/UserIdentifier) is\n    // a oneof\n    // (https://protobuf.dev/programming-guides/proto3/#oneof-features), you must set only\n    // ONE of 'hashed_email, 'hashed_phone_number', 'mobile_id', 'third_party_user_id', or\n    // 'address_info'.\n    // Setting more than one of these attributes on the same UserIdentifier will clear all\n    // the other members of the oneof. For example, the following code is INCORRECT and will\n    // result in a UserIdentifier with ONLY a 'hashed_phone_number'.\n    //\n    // $incorrectlyPopulatedUserIdentifier = new UserIdentifier();\n    // $incorrectlyPopulatedUserIdentifier->setHashedEmail('...');\n    // $incorrectlyPopulatedUserIdentifier->setHashedPhoneNumber('...');\n    //\n    // The separate 'if' statements below demonstrate the correct approach for creating a\n    // UserData for a member with multiple UserIdentifiers.\n\n    $userIdentifiers = [];\n    // Checks if the record has an email address, and if so, adds a UserIdentifier for it.\n    if (array_key_exists('email', $rawRecord)) {\n        $hashedEmailIdentifier = new UserIdentifier([\n            'hashed_email' => self::normalizeAndHash($rawRecord['email'], true)\n        ]);\n        // Adds the hashed email identifier to the user identifiers list.\n        $userIdentifiers[] = $hashedEmailIdentifier;\n    }\n\n    // Checks if the record has a phone number, and if so, adds a UserIdentifier for it.\n    if (array_key_exists('phone', $rawRecord)) {\n        $hashedPhoneNumberIdentifier = new UserIdentifier([\n            'hashed_phone_number' => self::normalizeAndHash($rawRecord['phone'], true)\n        ]);\n        // Adds the hashed email identifier to the user identifiers list.\n        $userIdentifiers[] = $hashedPhoneNumberIdentifier;\n    }\n\n    // Checks if the record has all the required mailing address elements, and if so, adds a\n    // UserIdentifier for the mailing address.\n    if (array_key_exists('firstName', $rawRecord)) {\n        // Checks if the record contains all the other required elements of a mailing\n        // address.\n        $missingAddressKeys = [];\n        foreach (['lastName', 'countryCode', 'postalCode'] as $addressKey) {\n            if (!array_key_exists($addressKey, $rawRecord)) {\n                $missingAddressKeys[] = $addressKey;\n            }\n        }\n        if (!empty($missingAddressKeys)) {\n            printf(\n                \"Skipping addition of mailing address information because the \"\n                . \"following required keys are missing: %s%s\",\n                json_encode($missingAddressKeys),\n                PHP_EOL\n            );\n        } else {\n            // Creates an OfflineUserAddressInfo object that contains all the required\n            // elements of a mailing address.\n            $addressIdentifier = new UserIdentifier([\n               'address_info' => new OfflineUserAddressInfo([\n                   'hashed_first_name' => self::normalizeAndHash(\n                       $rawRecord['firstName'],\n                       false\n                   ),\n                   'hashed_last_name' => self::normalizeAndHash(\n                       $rawRecord['lastName'],\n                       false\n                   ),\n                   'country_code' => $rawRecord['countryCode'],\n                   'postal_code' => $rawRecord['postalCode']\n               ])\n            ]);\n            // Adds the address identifier to the user identifiers list.\n            $userIdentifiers[] = $addressIdentifier;\n        }\n    }\n    if (!empty($userIdentifiers)) {\n        // Builds the UserData and adds it to the list.\n        $userDataList[] = new UserData(['user_identifiers' => $userIdentifiers]);\n    }\n}\n\n// Creates the operations to add users.\n$operations = array_map(\n    function (UserData $userData) {\n        return new OfflineUserDataJobOperation(['create' => $userData]);\n    },\n    $userDataList\n);AddCustomerMatchUserList.php",
    "def build_offline_user_data_job_operations(\n    client: GoogleAdsClient,\n) -> List[OfflineUserDataJobOperation]:\n    \"\"\"Creates a raw input list of unhashed user information.\n\n    Each element of the list represents a single user and is a dict containing a\n    separate entry for the keys \"email\", \"phone\", \"first_name\", \"last_name\",\n    \"country_code\", and \"postal_code\". In your application, this data might come\n    from a file or a database.\n\n    Args:\n        client: The Google Ads client.\n\n    Returns:\n        A list containing the operations.\n    \"\"\"\n    # The first user data has an email address and a phone number.\n    raw_record_1: Dict[str, str] = {\n        \"email\": \"dana@example.com\",\n        # Phone number to be converted to E.164 format, with a leading '+' as\n        # required. This includes whitespace that will be removed later.\n        \"phone\": \"+1 800 5550101\",\n    }\n\n    # The second user data has an email address, a mailing address, and a phone\n    # number.\n    raw_record_2: Dict[str, str] = {\n        # Email address that includes a period (.) before the email domain.\n        \"email\": \"alex.2@example.com\",\n        # Address that includes all four required elements: first name, last\n        # name, country code, and postal code.\n        \"first_name\": \"Alex\",\n        \"last_name\": \"Quinn\",\n        \"country_code\": \"US\",\n        \"postal_code\": \"94045\",\n        # Phone number to be converted to E.164 format, with a leading '+' as\n        # required.\n        \"phone\": \"+1 800 5550102\",\n    }\n\n    # The third user data only has an email address.\n    raw_record_3: Dict[str, str] = {\"email\": \"charlie@example.com\"}\n\n    # Adds the raw records to a raw input list.\n    raw_records: List[Dict[str, str]] = [\n        raw_record_1,\n        raw_record_2,\n        raw_record_3,\n    ]\n\n    operations: List[OfflineUserDataJobOperation] = []\n    # Iterates over the raw input list and creates a UserData object for each\n    # record.\n    for record in raw_records:\n        # Creates a UserData object that represents a member of the user list.\n        user_data: UserData = client.get_type(\"UserData\")\n\n        # Checks if the record has email, phone, or address information, and\n        # adds a SEPARATE UserIdentifier object for each one found. For example,\n        # a record with an email address and a phone number will result in a\n        # UserData with two UserIdentifiers.\n\n        # IMPORTANT: Since the identifier attribute of UserIdentifier\n        # (https://developers.google.com/google-ads/api/reference/rpc/latest/UserIdentifier)\n        # is a oneof\n        # (https://protobuf.dev/programming-guides/proto3/#oneof-features), you\n        # must set only ONE of hashed_email, hashed_phone_number, mobile_id,\n        # third_party_user_id, or address-info. Setting more than one of these\n        # attributes on the same UserIdentifier will clear all the other members\n        # of the oneof. For example, the following code is INCORRECT and will\n        # result in a UserIdentifier with ONLY a hashed_phone_number:\n\n        # incorrect_user_identifier = client.get_type(\"UserIdentifier\")\n        # incorrect_user_identifier.hashed_email = \"...\"\n        # incorrect_user_identifier.hashed_phone_number = \"...\"\n\n        # The separate 'if' statements below demonstrate the correct approach\n        # for creating a UserData object for a member with multiple\n        # UserIdentifiers.\n\n        # Checks if the record has an email address, and if so, adds a\n        # UserIdentifier for it.\n        if \"email\" in record:\n            user_identifier: UserIdentifier = client.get_type(\"UserIdentifier\")\n            user_identifier.hashed_email = normalize_and_hash(\n                record[\"email\"], True\n            )\n            # Adds the hashed email identifier to the UserData object's list.\n            user_data.user_identifiers.append(user_identifier)\n\n        # Checks if the record has a phone number, and if so, adds a\n        # UserIdentifier for it.\n        if \"phone\" in record:\n            user_identifier: UserIdentifier = client.get_type(\"UserIdentifier\")\n            user_identifier.hashed_phone_number = normalize_and_hash(\n                record[\"phone\"], True\n            )\n            # Adds the hashed phone number identifier to the UserData object's\n            # list.\n            user_data.user_identifiers.append(user_identifier)\n\n        # Checks if the record has all the required mailing address elements,\n        # and if so, adds a UserIdentifier for the mailing address.\n        if \"first_name\" in record:\n            required_keys = (\"last_name\", \"country_code\", \"postal_code\")\n            # Checks if the record contains all the other required elements of\n            # a mailing address.\n            if not all(key in record for key in required_keys):\n                # Determines which required elements are missing from the\n                # record.\n                missing_keys = record.keys() - required_keys\n                print(\n                    \"Skipping addition of mailing address information \"\n                    \"because the following required keys are missing: \"\n                    f\"{missing_keys}\"\n                )\n            else:\n                user_identifier: UserIdentifier = client.get_type(\n                    \"UserIdentifier\"\n                )\n                address_info: AddressInfo = user_identifier.address_info\n                address_info.hashed_first_name = normalize_and_hash(\n                    record[\"first_name\"], False\n                )\n                address_info.hashed_last_name = normalize_and_hash(\n                    record[\"last_name\"], False\n                )\n                address_info.country_code = record[\"country_code\"]\n                address_info.postal_code = record[\"postal_code\"]\n                user_data.user_identifiers.append(user_identifier)\n\n        # If the user_identifiers repeated field is not empty, create a new\n        # OfflineUserDataJobOperation and add the UserData to it.\n        if user_data.user_identifiers:\n            operation: OfflineUserDataJobOperation = client.get_type(\n                \"OfflineUserDataJobOperation\"\n            )\n            operation.create = user_data\n            operations.append(operation)add_customer_match_user_list.py",
    "# Create a list of unhashed user data records that we will format in the\n# following steps to prepare for the API.\nraw_records = [\n  # The first user data has an email address and a phone number.\n  {\n    email: 'dana@example.com',\n    # Phone number to be converted to E.164 format, with a leading '+' as\n    # required. This includes whitespace that will be removed later.\n    phone: '+1 800 5550100',\n  },\n  # The second user data has an email address, a phone number, and an address.\n  {\n    # Email address that includes a period (.) before the Gmail domain.\n    email: 'alex.2@example.com',\n    # Address that includes all four required elements: first name, last\n    # name, country code, and postal code.\n    first_name: 'Alex',\n    last_name: 'Quinn',\n    country_code: 'US',\n    postal_code: '94045',\n    # Phone number to be converted to E.164 format, with a leading '+' as\n    # required.\n    phone: '+1 800 5550102',\n  },\n  # The third user data only has an email address.\n  {\n    email: 'charlie@example.com',\n  },\n]\n\n# Create a UserData for each entry in the raw records.\nuser_data_list = raw_records.map do |record|\n  client.resource.user_data do |data|\n    if record[:email]\n      data.user_identifiers << client.resource.user_identifier do |ui|\n        ui.hashed_email = normalize_and_hash(record[:email], true)\n      end\n    end\n    if record[:phone]\n      data.user_identifiers << client.resource.user_identifier do |ui|\n        ui.hashed_phone_number = normalize_and_hash(record[:phone], true)\n      end\n    end\n    if record[:first_name]\n      # Check that we have all the required information.\n      missing_keys = [:last_name, :country_code, :postal_code].reject {|key|\n        record[key].nil?\n      }\n      if missing_keys.empty?\n        # If nothing is missing, add the address.\n        data.user_identifiers << client.resource.user_identifier do |ui|\n          ui.address_identifier = client.resource.offline_user_address_info do |address|\n            address.hashed_first_name = normalize_and_hash(record[:first_name])\n            address.hashed_last_name = normalize_and_hash(record[:last_name])\n            address.country_code = record[:country_code]\n            address.postal_code = record[:postal_code]\n          end\n        end\n      else\n        # If some data is missing, skip this entry.\n        puts \"Skipping addition of mailing information because the following keys are missing:\" \\\n          \"#{missing_keys}\"\n      end\n    end\n  end\nend\n\noperations = user_data_list.map do |user_data|\n  client.operation.create_resource.offline_user_data_job(user_data)\nendadd_customer_match_user_list.rb",
    "# The first user data has an email address and a phone number.\n  my $raw_record_1 = {\n    email => 'dana@example.com',\n    # Phone number to be converted to E.164 format, with a leading '+' as\n    # required. This includes whitespace that will be removed later.\n    phone => '+1 800 5550101',\n  };\n\n  # The second user data has an email address, a mailing address, and a phone\n  # number.\n  my $raw_record_2 = {\n    # Email address that includes a period (.) before the Gmail domain.\n    email => 'alex.2@example.com',\n    # Address that includes all four required elements: first name, last\n    # name, country code, and postal code.\n    firstName   => 'Alex',\n    lastName    => 'Quinn',\n    countryCode => 'US',\n    postalCode  => '94045',\n    # Phone number to be converted to E.164 format, with a leading '+' as\n    # required.\n    phone => '+1 800 5550102',\n  };\n\n  # The third user data only has an email address.\n  my $raw_record_3 = {email => 'charlie@example.com',};\n\n  my $raw_records = [$raw_record_1, $raw_record_2, $raw_record_3];\n\n  my $operations = [];\n  foreach my $record (@$raw_records) {\n    # Check if the record has email, phone, or address information, and adds a\n    # SEPARATE UserIdentifier object for each one found. For example, a record\n    # with an email address and a phone number will result in a UserData with two\n    # UserIdentifiers.\n    #\n    # IMPORTANT: Since the identifier attribute of UserIdentifier\n    # (https://developers.google.com/google-ads/api/reference/rpc/latest/UserIdentifier)\n    # is a oneof\n    # (https://protobuf.dev/programming-guides/proto3/#oneof-features), you must set\n    # only ONE of hashed_email, hashed_phone_number, mobile_id, third_party_user_id,\n    # or address-info. Setting more than one of these attributes on the same UserIdentifier\n    # will clear all the other members of the oneof. For example, the following code is\n    # INCORRECT and will result in a UserIdentifier with ONLY a hashed_phone_number:\n    #\n    # my $incorrect_user_identifier = Google::Ads::GoogleAds::V22::Common::UserIdentifier->new({\n    #   hashedEmail => '...',\n    #   hashedPhoneNumber => '...',\n    # });\n    #\n    # The separate 'if' statements below demonstrate the correct approach for creating a\n    # UserData object for a member with multiple UserIdentifiers.\n\n    my $user_identifiers = [];\n\n    # Check if the record has an email address, and if so, add a UserIdentifier for it.\n    if (defined $record->{email}) {\n      # Add the hashed email identifier to the list of UserIdentifiers.\n      push(\n        @$user_identifiers,\n        Google::Ads::GoogleAds::V22::Common::UserIdentifier->new({\n            hashedEmail => normalize_and_hash($record->{email}, 1)}));\n    }\n\n    # Check if the record has a phone number, and if so, add a UserIdentifier for it.\n    if (defined $record->{phone}) {\n      # Add the hashed phone number identifier to the list of UserIdentifiers.\n      push(\n        @$user_identifiers,\n        Google::Ads::GoogleAds::V22::Common::UserIdentifier->new({\n            hashedPhoneNumber => normalize_and_hash($record->{phone}, 1)}));\n    }\n\n    # Check if the record has all the required mailing address elements, and if so, add\n    # a UserIdentifier for the mailing address.\n    if (defined $record->{firstName}) {\n      my $required_keys = [\"lastName\", \"countryCode\", \"postalCode\"];\n      my $missing_keys  = [];\n\n      foreach my $key (@$required_keys) {\n        if (!defined $record->{$key}) {\n          push(@$missing_keys, $key);\n        }\n      }\n\n      if (@$missing_keys) {\n        print\n\"Skipping addition of mailing address information because the following\"\n          . \"keys are missing: \"\n          . join(\",\", @$missing_keys);\n      } else {\n        push(\n          @$user_identifiers,\n          Google::Ads::GoogleAds::V22::Common::UserIdentifier->new({\n              addressInfo =>\n                Google::Ads::GoogleAds::V22::Common::OfflineUserAddressInfo->\n                new({\n                  # First and last name must be normalized and hashed.\n                  hashedFirstName => normalize_and_hash($record->{firstName}),\n                  hashedLastName  => normalize_and_hash($record->{lastName}),\n                  # Country code and zip code are sent in plain text.\n                  countryCode => $record->{countryCode},\n                  postalCode  => $record->{postalCode},\n                })}));\n      }\n    }\n\n    # If the user_identifiers array is not empty, create a new\n    # OfflineUserDataJobOperation and add the UserData to it.\n    if (@$user_identifiers) {\n      my $user_data = Google::Ads::GoogleAds::V22::Common::UserData->new({\n          userIdentifiers => [$user_identifiers]});\n      push(\n        @$operations,\n        Google::Ads::GoogleAds::V22::Services::OfflineUserDataJobService::OfflineUserDataJobOperation\n          ->new({\n            create => $user_data\n          }));\n    }\n  }add_customer_match_user_list.pl",
    "OfflineUserDataJob",
    "operation_metadata.match_rate_range",
    "private void checkJobStatus(\n    GoogleAdsClient googleAdsClient, long customerId, String offlineUserDataJobResourceName) {\n  try (GoogleAdsServiceClient googleAdsServiceClient =\n      googleAdsClient.getLatestVersion().createGoogleAdsServiceClient()) {\n    String query =\n        String.format(\n            \"SELECT offline_user_data_job.resource_name, \"\n                + \"offline_user_data_job.id, \"\n                + \"offline_user_data_job.status, \"\n                + \"offline_user_data_job.type, \"\n                + \"offline_user_data_job.failure_reason, \"\n                + \"offline_user_data_job.customer_match_user_list_metadata.user_list \"\n                + \"FROM offline_user_data_job \"\n                + \"WHERE offline_user_data_job.resource_name = '%s'\",\n            offlineUserDataJobResourceName);\n    // Issues the query and gets the GoogleAdsRow containing the job from the response.\n    GoogleAdsRow googleAdsRow =\n        googleAdsServiceClient\n            .search(Long.toString(customerId), query)\n            .iterateAll()\n            .iterator()\n            .next();\n    OfflineUserDataJob offlineUserDataJob = googleAdsRow.getOfflineUserDataJob();\n    System.out.printf(\n        \"Offline user data job ID %d with type '%s' has status: %s%n\",\n        offlineUserDataJob.getId(), offlineUserDataJob.getType(), offlineUserDataJob.getStatus());\n    OfflineUserDataJobStatus jobStatus = offlineUserDataJob.getStatus();\n    if (OfflineUserDataJobStatus.SUCCESS == jobStatus) {\n      // Prints information about the user list.\n      printCustomerMatchUserListInfo(\n          googleAdsClient,\n          customerId,\n          offlineUserDataJob.getCustomerMatchUserListMetadata().getUserList());\n    } else if (OfflineUserDataJobStatus.FAILED == jobStatus) {\n      System.out.printf(\"  Failure reason: %s%n\", offlineUserDataJob.getFailureReason());\n    } else if (OfflineUserDataJobStatus.PENDING == jobStatus\n        || OfflineUserDataJobStatus.RUNNING == jobStatus) {\n      System.out.println();\n      System.out.printf(\n          \"To check the status of the job periodically, use the following GAQL query with\"\n              + \" GoogleAdsService.search:%n%s%n\",\n          query);\n    }\n  }\n}\nAddCustomerMatchUserList.java",
    "private static void CheckJobStatusAndPrintResults(GoogleAdsClient client, long customerId,\n    string offlineUserDataJobResourceName)\n{\n    // Get the GoogleAdsService.\n    GoogleAdsServiceClient service = client.GetService(Services.V22.GoogleAdsService);\n\n    string query = \"SELECT offline_user_data_job.resource_name, \" +\n        \"offline_user_data_job.id, offline_user_data_job.status, \" +\n        \"offline_user_data_job.type, offline_user_data_job.failure_reason, \" +\n        \"offline_user_data_job.customer_match_user_list_metadata.user_list \" +\n        \"FROM offline_user_data_job WHERE \" +\n        $\"offline_user_data_job.resource_name = '{offlineUserDataJobResourceName}'\";\n\n    // Issues the query and gets the GoogleAdsRow containing the job from the response.\n    GoogleAdsRow googleAdsRow = service.Search(customerId.ToString(), query).First();\n\n    OfflineUserDataJob offlineUserDataJob = googleAdsRow.OfflineUserDataJob;\n    Console.WriteLine($\"Offline user data job ID {offlineUserDataJob.Id} with type \" +\n        $\"'{offlineUserDataJob.Type}' has status: {offlineUserDataJob.Status}\");\n\n    switch (offlineUserDataJob.Status)\n    {\n        case OfflineUserDataJobStatus.Success:\n            // Prints information about the user list.\n            PrintCustomerMatchUserListInfo(client, customerId,\n                offlineUserDataJob.CustomerMatchUserListMetadata.UserList);\n            break;\n\n        case OfflineUserDataJobStatus.Failed:\n            Console.WriteLine($\"  Failure reason: {offlineUserDataJob.FailureReason}\");\n            break;\n\n        case OfflineUserDataJobStatus.Pending:\n        case OfflineUserDataJobStatus.Running:\n            Console.WriteLine(\"To check the status of the job periodically, use the \" +\n                $\"following GAQL query with GoogleAdsService.search:\\n\\n{query}\");\n            break;\n    }\n}AddCustomerMatchUserList.cs",
    "private static function checkJobStatus(\n    GoogleAdsClient $googleAdsClient,\n    int $customerId,\n    string $offlineUserDataJobResourceName\n) {\n    $googleAdsServiceClient = $googleAdsClient->getGoogleAdsServiceClient();\n\n    // Creates a query that retrieves the offline user data job.\n    $query = \"SELECT offline_user_data_job.resource_name, \"\n          . \"offline_user_data_job.id, \"\n          . \"offline_user_data_job.status, \"\n          . \"offline_user_data_job.type, \"\n          . \"offline_user_data_job.failure_reason, \"\n          . \"offline_user_data_job.customer_match_user_list_metadata.user_list \"\n          . \"FROM offline_user_data_job \"\n          . \"WHERE offline_user_data_job.resource_name = '$offlineUserDataJobResourceName'\";\n\n    // Issues a search request to get the GoogleAdsRow containing the job from the response.\n    /** @var GoogleAdsRow $googleAdsRow */\n    $googleAdsRow =\n        $googleAdsServiceClient->search(SearchGoogleAdsRequest::build($customerId, $query))\n            ->getIterator()\n            ->current();\n    $offlineUserDataJob = $googleAdsRow->getOfflineUserDataJob();\n\n    // Prints out some information about the offline user data job.\n    $offlineUserDataJobStatus = $offlineUserDataJob->getStatus();\n    printf(\n        \"Offline user data job ID %d with type '%s' has status: %s.%s\",\n        $offlineUserDataJob->getId(),\n        OfflineUserDataJobType::name($offlineUserDataJob->getType()),\n        OfflineUserDataJobStatus::name($offlineUserDataJobStatus),\n        PHP_EOL\n    );\n\n    if ($offlineUserDataJobStatus === OfflineUserDataJobStatus::SUCCESS) {\n        // Prints information about the user list.\n        self::printCustomerMatchUserListInfo(\n            $googleAdsClient,\n            $customerId,\n            $offlineUserDataJob->getCustomerMatchUserListMetadata()->getUserList()\n        );\n    } elseif ($offlineUserDataJobStatus === OfflineUserDataJobStatus::FAILED) {\n        printf(\"  Failure reason: %s.%s\", $offlineUserDataJob->getFailureReason(), PHP_EOL);\n    } elseif (\n        $offlineUserDataJobStatus === OfflineUserDataJobStatus::PENDING\n        || $offlineUserDataJobStatus === OfflineUserDataJobStatus::RUNNING\n    ) {\n        printf(\n            '%1$sTo check the status of the job periodically, use the following GAQL query with'\n            . ' GoogleAdsService.search:%1$s%2$s%1$s',\n            PHP_EOL,\n            $query\n        );\n    }\n}AddCustomerMatchUserList.php",
    "def check_job_status(\n    client: GoogleAdsClient,\n    customer_id: str,\n    offline_user_data_job_resource_name: str,\n) -> None:\n    \"\"\"Retrieves, checks, and prints the status of the offline user data job.\n\n    If the job is completed successfully, information about the user list is\n    printed. Otherwise, a GAQL query will be printed, which can be used to\n    check the job status at a later date.\n\n    Offline user data jobs may take 6 hours or more to complete, so checking the\n    status periodically, instead of waiting, can be more efficient.\n\n    Args:\n        client: The Google Ads client.\n        customer_id: The ID for the customer that owns the user list.\n        offline_user_data_job_resource_name: The resource name of the offline\n            user data job to get the status of.\n    \"\"\"\n    query: str = f\"\"\"\n        SELECT\n          offline_user_data_job.resource_name,\n          offline_user_data_job.id,\n          offline_user_data_job.status,\n          offline_user_data_job.type,\n          offline_user_data_job.failure_reason,\n          offline_user_data_job.customer_match_user_list_metadata.user_list\n        FROM offline_user_data_job\n        WHERE offline_user_data_job.resource_name =\n          '{offline_user_data_job_resource_name}'\n        LIMIT 1\"\"\"\n\n    # Issues a search request using streaming.\n    google_ads_service: GoogleAdsServiceClient = client.get_service(\n        \"GoogleAdsService\"\n    )\n    results: SearchGoogleAdsStreamResponse = google_ads_service.search(\n        customer_id=customer_id, query=query\n    )\n    offline_user_data_job_result: OfflineUserDataJob = next(\n        iter(results)\n    ).offline_user_data_job\n    status_name: str = offline_user_data_job_result.status.name\n    user_list_resource_name: str = (\n        offline_user_data_job_result.customer_match_user_list_metadata.user_list\n    )\n\n    print(\n        f\"Offline user data job ID '{offline_user_data_job_result.id}' with type \"\n        f\"'{offline_user_data_job_result.type_.name}' has status: {status_name}\"\n    )\n\n    if status_name == \"SUCCESS\":\n        print_customer_match_user_list_info(\n            client, customer_id, user_list_resource_name\n        )\n    elif status_name == \"FAILED\":\n        print(\n            f\"\\tFailure Reason: {offline_user_data_job_result.failure_reason}\"\n        )\n    elif status_name in (\"PENDING\", \"RUNNING\"):\n        print(\n            \"To check the status of the job periodically, use the following \"\n            f\"GAQL query with GoogleAdsService.Search: {query}\"\n        )add_customer_match_user_list.py",
    "def check_job_status(client, customer_id, offline_user_data_job)\n  query = <<~QUERY\n    SELECT\n      offline_user_data_job.id,\n      offline_user_data_job.status,\n      offline_user_data_job.type,\n      offline_user_data_job.failure_reason,\n      offline_user_data_job.customer_match_user_list_metadata.user_list\n    FROM\n      offline_user_data_job\n    WHERE\n      offline_user_data_job.resource_name = '#{offline_user_data_job}'\n  QUERY\n\n  row = client.service.google_ads.search(\n    customer_id: customer_id,\n    query: query,\n  ).first\n\n  job = row.offline_user_data_job\n  puts \"Offline user data job ID #{job.id} with type '#{job.type}' has status: #{job.status}.\"\n\n  case job.status\n  when :SUCCESS\n    print_customer_match_user_list(client, customer_id, job.customer_match_user_list_metadata.user_list)\n  when :FAILED\n    puts \"  Failure reason: #{job.failure_reason}\"\n  else\n    puts \"  To check the status of the job periodically, use the following GAQL \" \\\n      \"query with GoogleAdsService.search:\"\n    puts query\n  end\nendadd_customer_match_user_list.rb",
    "sub check_job_status {\n  my ($api_client, $customer_id, $offline_user_data_job_resource_name) = @_;\n\n  my $search_query =\n    \"SELECT offline_user_data_job.resource_name, \" .\n    \"offline_user_data_job.id, offline_user_data_job.status, \" .\n    \"offline_user_data_job.type, offline_user_data_job.failure_reason, \" .\n    \"offline_user_data_job.customer_match_user_list_metadata.user_list \" .\n    \"FROM offline_user_data_job \" .\n    \"WHERE offline_user_data_job.resource_name = \" .\n    \"'$offline_user_data_job_resource_name' LIMIT 1\";\n\n  my $search_request =\n    Google::Ads::GoogleAds::V22::Services::GoogleAdsService::SearchGoogleAdsRequest\n    ->new({\n      customerId => $customer_id,\n      query      => $search_query\n    });\n\n  # Get the GoogleAdsService.\n  my $google_ads_service = $api_client->GoogleAdsService();\n\n  my $iterator = Google::Ads::GoogleAds::Utils::SearchGoogleAdsIterator->new({\n    service => $google_ads_service,\n    request => $search_request\n  });\n\n  # The results have exactly one row.\n  my $google_ads_row        = $iterator->next;\n  my $offline_user_data_job = $google_ads_row->{offlineUserDataJob};\n  my $status                = $offline_user_data_job->{status};\n\n  printf\n    \"Offline user data job ID %d with type %s has status: %s.\\n\",\n    $offline_user_data_job->{id},\n    $offline_user_data_job->{type},\n    $status;\n\n  if ($status eq SUCCESS) {\n    print_customer_match_user_list_info($api_client, $customer_id,\n      $offline_user_data_job->{customerMatchUserListMetadata}{userList});\n  } elsif ($status eq FAILED) {\n    print \"Failure reason: $offline_user_data_job->{failureReason}\";\n  } elsif (grep /$status/, (PENDING, RUNNING)) {\n    print\n      \"To check the status of the job periodically, use the following GAQL \" .\n      \"query with the GoogleAdsService->search() method:\\n$search_query\\n\";\n  }\n\n  return 1;\n}add_customer_match_user_list.pl",
    "try (GoogleAdsServiceClient googleAdsServiceClient =\n    googleAdsClient.getLatestVersion().createGoogleAdsServiceClient()) {\n  // Creates a query that retrieves the user list.\n  String query =\n      String.format(\n          \"SELECT user_list.size_for_display, user_list.size_for_search \"\n              + \"FROM user_list \"\n              + \"WHERE user_list.resource_name = '%s'\",\n          userListResourceName);\n\n  // Constructs the SearchGoogleAdsStreamRequest.\n  SearchGoogleAdsStreamRequest request =\n      SearchGoogleAdsStreamRequest.newBuilder()\n          .setCustomerId(Long.toString(customerId))\n          .setQuery(query)\n          .build();\n\n  // Issues the search stream request.\n  ServerStream<SearchGoogleAdsStreamResponse> stream =\n      googleAdsServiceClient.searchStreamCallable().call(request);AddCustomerMatchUserList.java",
    "// Get the GoogleAdsService.\n GoogleAdsServiceClient service =\n     client.GetService(Services.V22.GoogleAdsService);\n\n // Creates a query that retrieves the user list.\n string query =\n     \"SELECT user_list.size_for_display, user_list.size_for_search \" +\n     \"FROM user_list \" +\n     $\"WHERE user_list.resource_name = '{userListResourceName}'\";\n // Issues a search stream request.\n service.SearchStream(customerId.ToString(), query,\n    delegate (SearchGoogleAdsStreamResponse resp)\n    {\n        // Display the results.\n        foreach (GoogleAdsRow userListRow in resp.Results)\n        {\n            UserList userList = userListRow.UserList;\n            Console.WriteLine(\"The estimated number of users that the user list \" +\n                $\"'{userList.ResourceName}' has is {userList.SizeForDisplay}\" +\n                $\" for Display and {userList.SizeForSearch} for Search.\");\n        }\n    }\n);AddCustomerMatchUserList.cs",
    "$googleAdsServiceClient = $googleAdsClient->getGoogleAdsServiceClient();\n\n// Creates a query that retrieves the user list.\n$query =\n    \"SELECT user_list.size_for_display, user_list.size_for_search \" .\n    \"FROM user_list \" .\n    \"WHERE user_list.resource_name = '$userListResourceName'\";\n\n// Issues a search stream request.\n/** @var GoogleAdsServerStreamDecorator $stream */\n$stream = $googleAdsServiceClient->searchStream(\n    SearchGoogleAdsStreamRequest::build($customerId, $query)\n);AddCustomerMatchUserList.php",
    "googleads_service_client: GoogleAdsServiceClient = client.get_service(\n    \"GoogleAdsService\"\n)\n\n# Creates a query that retrieves the user list.\nquery: str = f\"\"\"\n    SELECT\n      user_list.size_for_display,\n      user_list.size_for_search\n    FROM user_list\n    WHERE user_list.resource_name = '{user_list_resource_name}'\"\"\"\n\n# Issues a search request.\nsearch_results: SearchGoogleAdsStreamResponse = (\n    googleads_service_client.search(customer_id=customer_id, query=query)\n)add_customer_match_user_list.py",
    "query = <<~EOQUERY\n  SELECT user_list.size_for_display, user_list.size_for_search\n  FROM user_list\n  WHERE user_list.resource_name = #{user_list}\nEOQUERY\n\nresponse = client.service.google_ads.search_stream(\n  customer_id: customer_id,\n  query: query,\n)add_customer_match_user_list.rb",
    "# Create a query that retrieves the user list.\nmy $search_query =\n  \"SELECT user_list.size_for_display, user_list.size_for_search \" .\n  \"FROM user_list \" .\n  \"WHERE user_list.resource_name = '$user_list_resource_name'\";\n\n# Create a search Google Ads stream request that will retrieve the user list.\nmy $search_stream_request =\n  Google::Ads::GoogleAds::V22::Services::GoogleAdsService::SearchGoogleAdsStreamRequest\n  ->new({\n    customerId => $customer_id,\n    query      => $search_query,\n  });\n\n# Get the GoogleAdsService.\nmy $google_ads_service = $api_client->GoogleAdsService();\n\nmy $search_stream_handler =\n  Google::Ads::GoogleAds::Utils::SearchStreamHandler->new({\n    service => $google_ads_service,\n    request => $search_stream_request\n  });add_customer_match_user_list.pl",
    "OfflineUserDataJob",
    "offline_user_data_job",
    "In Progress",
    "private String targetAdsInAdGroupToUserList(\n    GoogleAdsClient googleAdsClient, long customerId, long adGroupId, String userList) {\n  // Creates the ad group criterion targeting members of the user list.\n  AdGroupCriterion adGroupCriterion =\n      AdGroupCriterion.newBuilder()\n          .setAdGroup(ResourceNames.adGroup(customerId, adGroupId))\n          .setUserList(UserListInfo.newBuilder().setUserList(userList).build())\n          .build();\n\n  // Creates the operation.\n  AdGroupCriterionOperation operation =\n      AdGroupCriterionOperation.newBuilder().setCreate(adGroupCriterion).build();\n\n  // Creates the ad group criterion service.\n  try (AdGroupCriterionServiceClient adGroupCriterionServiceClient =\n      googleAdsClient.getLatestVersion().createAdGroupCriterionServiceClient()) {\n    // Adds the ad group criterion.\n    MutateAdGroupCriteriaResponse response =\n        adGroupCriterionServiceClient.mutateAdGroupCriteria(\n            Long.toString(customerId), ImmutableList.of(operation));\n    // Gets and prints the results.\n    String adGroupCriterionResourceName = response.getResults(0).getResourceName();\n    System.out.printf(\n        \"Successfully created ad group criterion with resource name '%s' \"\n            + \"targeting user list with resource name '%s' with ad group with ID %d.%n\",\n        adGroupCriterionResourceName, userList, adGroupId);\n    return adGroupCriterionResourceName;\n  }\n}\nSetUpRemarketing.java",
    "private string TargetAdsInAdGroupToUserList(\n    GoogleAdsClient client, long customerId, long adGroupId, string userListResourceName)\n{\n    // Get the AdGroupCriterionService client.\n    AdGroupCriterionServiceClient adGroupCriterionServiceClient = client.GetService\n        (Services.V22.AdGroupCriterionService);\n\n    // Create the ad group criterion targeting members of the user list.\n    AdGroupCriterion adGroupCriterion = new AdGroupCriterion\n    {\n        AdGroup = ResourceNames.AdGroup(customerId, adGroupId),\n        UserList = new UserListInfo\n        {\n            UserList = userListResourceName\n        }\n    };\n\n    // Create the operation.\n    AdGroupCriterionOperation adGroupCriterionOperation = new AdGroupCriterionOperation\n    {\n        Create = adGroupCriterion\n    };\n\n    // Add the ad group criterion, then print and return the new criterion's resource name.\n    MutateAdGroupCriteriaResponse mutateAdGroupCriteriaResponse =\n        adGroupCriterionServiceClient.MutateAdGroupCriteria(customerId.ToString(),\n            new[] { adGroupCriterionOperation });\n\n    string adGroupCriterionResourceName =\n        mutateAdGroupCriteriaResponse.Results.First().ResourceName;\n    Console.WriteLine(\"Successfully created ad group criterion with resource name \" +\n        $\"'{adGroupCriterionResourceName}' targeting user list with resource name \" +\n        $\"'{userListResourceName}' with ad group with ID {adGroupId}.\");\n    return adGroupCriterionResourceName;\n}SetUpRemarketing.cs",
    "private static function targetAdsInAdGroupToUserList(\n    GoogleAdsClient $googleAdsClient,\n    int $customerId,\n    int $adGroupId,\n    string $userListResourceName\n): string {\n    // Creates the ad group criterion targeting members of the user list.\n    $adGroupCriterion = new AdGroupCriterion([\n        'ad_group' => ResourceNames::forAdGroup($customerId, $adGroupId),\n        'user_list' => new UserListInfo(['user_list' => $userListResourceName])\n    ]);\n\n    // Creates the operation.\n    $operation = new AdGroupCriterionOperation();\n    $operation->setCreate($adGroupCriterion);\n\n    // Issues a mutate request to add an ad group criterion.\n    $adGroupCriterionServiceClient = $googleAdsClient->getAdGroupCriterionServiceClient();\n    /** @var MutateAdGroupCriteriaResponse $adGroupCriterionResponse */\n    $adGroupCriterionResponse = $adGroupCriterionServiceClient->mutateAdGroupCriteria(\n        MutateAdGroupCriteriaRequest::build($customerId, [$operation])\n    );\n\n    $adGroupCriterionResourceName =\n        $adGroupCriterionResponse->getResults()[0]->getResourceName();\n    printf(\n        \"Successfully created ad group criterion with resource name '%s' \" .\n        \"targeting user list with resource name '%s' with ad group with ID %d.%s\",\n        $adGroupCriterionResourceName,\n        $userListResourceName,\n        $adGroupId,\n        PHP_EOL\n    );\n\n    return $adGroupCriterionResourceName;\n}SetUpRemarketing.php",
    "def target_ads_in_ad_group_to_user_list(\n    client: GoogleAdsClient,\n    customer_id: str,\n    ad_group_id: str,\n    user_list_resource_name: str,\n) -> str:\n    \"\"\"Creates an ad group criterion that targets a user list with an ad group.\n\n    Args:\n        client: an initialized GoogleAdsClient instance.\n        customer_id: a str client customer ID used to create an ad group\n            criterion.\n        ad_group_id: a str ID for an ad group used to create an ad group\n            criterion that targets members of a user list.\n        user_list_resource_name: a str resource name for a user list.\n\n    Returns:\n        a str resource name for an ad group criterion.\n    \"\"\"\n    ad_group_criterion_operation: AdGroupCriterionOperation = client.get_type(\n        \"AdGroupCriterionOperation\"\n    )\n    # Creates the ad group criterion targeting members of the user list.\n    ad_group_criterion: AdGroupCriterion = ad_group_criterion_operation.create\n    ad_group_criterion.ad_group = client.get_service(\n        \"AdGroupService\"\n    ).ad_group_path(customer_id, ad_group_id)\n    ad_group_criterion.user_list.user_list = user_list_resource_name\n\n    ad_group_criterion_service: AdGroupCriterionServiceClient = (\n        client.get_service(\"AdGroupCriterionService\")\n    )\n    response: MutateAdGroupCriteriaResponse = (\n        ad_group_criterion_service.mutate_ad_group_criteria(\n            customer_id=customer_id, operations=[ad_group_criterion_operation]\n        )\n    )\n    resource_name: str = response.results[0].resource_name\n    print(\n        \"Successfully created ad group criterion with resource name: \"\n        f\"'{resource_name}' targeting user list with resource name: \"\n        f\"'{user_list_resource_name}' and with ad group with ID \"\n        f\"{ad_group_id}.\"\n    )\n    return resource_nameset_up_remarketing.py",
    "def target_ads_in_ad_group_to_user_list(\n  client,\n  customer_id,\n  ad_group_id,\n  user_list\n)\n  # Creates the ad group criterion targeting members of the user list.\n  operation = client.operation.create_resource.ad_group_criterion do |agc|\n    agc.ad_group = client.path.ad_group(customer_id, ad_group_id)\n    agc.user_list = client.resource.user_list_info do |info|\n      info.user_list = user_list\n    end\n  end\n\n  # Issues a mutate request to create the ad group criterion.\n  response = client.service.ad_group_criterion.mutate_ad_group_criteria(\n    customer_id: customer_id,\n    operations: [operation],\n  )\n  ad_group_criterion_resource_name = response.results.first.resource_name\n  puts \"Successfully created ad group criterion with resource name \" \\\n    \"'#{ad_group_criterion_resource_name}' targeting user list with resource name \" \\\n    \"'#{user_list}' with ad group with ID #{ad_group_id}\"\n\n  ad_group_criterion_resource_name\nendset_up_remarketing.rb",
    "sub target_ads_in_ad_group_to_user_list {\n  my ($api_client, $customer_id, $ad_group_id, $user_list_resource_name) = @_;\n\n  # Create the ad group criterion targeting members of the user list.\n  my $ad_group_criterion =\n    Google::Ads::GoogleAds::V22::Resources::AdGroupCriterion->new({\n      adGroup => Google::Ads::GoogleAds::V22::Utils::ResourceNames::ad_group(\n        $customer_id, $ad_group_id\n      ),\n      userList => Google::Ads::GoogleAds::V22::Common::UserListInfo->new({\n          userList => $user_list_resource_name\n        })});\n\n  # Create the operation.\n  my $ad_group_criterion_operation =\n    Google::Ads::GoogleAds::V22::Services::AdGroupCriterionService::AdGroupCriterionOperation\n    ->new({\n      create => $ad_group_criterion\n    });\n\n  # Add the ad group criterion, then print and return the new criterion's resource name.\n  my $ad_group_criteria_response =\n    $api_client->AdGroupCriterionService()->mutate({\n      customerId => $customer_id,\n      operations => [$ad_group_criterion_operation]});\n\n  my $ad_group_criterion_resource_name =\n    $ad_group_criteria_response->{results}[0]{resourceName};\n  printf \"Successfully created ad group criterion with resource name '%s' \" .\n    \"targeting user list with resource name '%s' with ad group with ID %d.\\n\",\n    $ad_group_criterion_resource_name, $user_list_resource_name, $ad_group_id;\n\n  return $ad_group_criterion_resource_name;\n}set_up_remarketing.pl",
    "crm_based_user_list",
    "crm_based_user_list",
    "logical_user_list",
    "crm_based_user_list"
  ],
  "tables": [
    {
      "headers": [
        "Customer Match upload services"
      ],
      "rows": [
        [
          "OfflineUserDataJobService (preferred)",
          "Most developers use this service. It is optimized for large uploads with\n  high throughput and returns success metrics upon completion. This guide\n  focuses primarily on this service."
        ],
        [
          "UserDataService",
          "This service is optimized to upload a small number of identifiers at a time\n  with sporadic updates and is not optimized to run continuously. It has a limit\n  of 10 operations per request. In addition, a single request can't contain more\n  than 100 items in total across all\n  user_identifiers.\n  For guidance on uploads\n  with this service, visit the guide\n  for managing your Customer Match integration.\n  Starting with version v15 of\n  the Google Ads API, you should populate the\n  consent\n  field of\n  customer_match_user_list_metadata\n  in your\n  UploadUserDataRequest\n  create requests. For remove requests, consent is not needed.\n  The API returns a response with\n  received_operations_count\n  set to zero indicating the request was not processed if\n  consent.ad_user_data or consent.ad_personalization\n  is DENIED. If an identifier has a consent of DENIED,\n  then you could request to remove the identifier from the user list  using the\n  remove operation of UploadUserDataRequest."
        ]
      ]
    },
    {
      "headers": [
        "Customer Match in different campaign types"
      ],
      "rows": [
        [
          "Search network",
          "Ads show on the search network."
        ],
        [
          "Display network",
          "Ads show on the display network, and on Gmail only if there are GSP\n  creatives."
        ],
        [
          "Display Expansion\n  on Search campaigns",
          "Ads show on the search network, and on Gmail only if there are GSP\n  creatives."
        ],
        [
          "Video campaigns",
          "Ads show on YouTube only if there are in-stream TrueView ads."
        ],
        [
          "Shopping campaigns",
          "Ads show in the Shopping tab."
        ]
      ]
    }
  ],
  "mainText": "To discuss and provide feedback on our products, join the official Google Ads Discord channel in the Google Advertising and Measurement Community server.\n        \n      \n    \n  \n  \n  \n\n  \n    \n    \n    \n  \n  \n    \n    \n    \n      \n  \n    \n        Home\n      \n  \n  \n    \n  \n  \n  \n    \n      \n      \n    \n    \n    \n      \n  \n    \n        Products\n      \n  \n  \n    \n  \n  \n  \n    \n      \n      \n    \n    \n    \n      \n  \n    \n        Google Ads API\n      \n  \n  \n    \n  \n  \n\n    \n      \n    \n    \n  \n    \n  \n  \n    \n\n  \n  \n    \n    Send feedback\n  \n  \n\n  \n    \n      Get started with Customer Match\n\n    \n    \n      \n    \n\n    \n      \n      Stay organized with collections\n    \n    \n      \n      Save and categorize content based on your preferences.\n    \n  \n    \n  \n      \n    \n  \n  \n\n  \n  \n  \n    \n    \n    \n  \n\n  \n    \n      \n  \n    \n    \n    \n    AI-generated Key Takeaways\n    \n  \n  \n    \n      \n        outlined_flag\n      \n    \n    \n      \n        \n          Customer Match lets advertisers target ads using their existing customer data, requiring uploading information like emails or phone numbers.\n\n        \n      \n        \n          Account eligibility based on policy compliance and payment history is required to use Customer Match features.\n\n        \n      \n        \n          The recommended workflow for Customer Match involves creating a customer list, using OfflineUserDataJob for bulk uploads, and running the job to process data.\n\n        \n      \n        \n          Key best practices for Customer Match include using one account to modify a list, maximizing operations per request, and avoiding mixing create and remove operations in the same job.\n\n        \n      \n        \n          After a job succeeds, you can verify the match rate, target the list, and note that list size in the UI is rounded and only shows active users.\n\n        \n      \n    \n  \n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\nCustomer Match lets you use your online and offline data to reach and re-engage\nwith your customers across Search, the Shopping tab, Gmail, YouTube, and\nDisplay. Using information that your customers have shared with you, Customer\nMatch targets ads to those customers and other customers like them. You can\nupload customer relationship management (CRM) data in bulk, append or remove\ndata, or use these user lists to create a\nlogical_user_list.\n\nSee the audience management\noverview\nfor a list of different audience segment types to compare Customer Match with\nother user list options.\n\nFind out more about Customer\nMatch and audience\ntargeting.\n\nPrerequisites\n\nNot every account is eligible to use Customer Match. To use Customer Match, your\naccount must have the following:\n\n\nA good history of policy compliance\nA good payment history\n\n\nDepending on which requirements your account satisfies, different features are\navailable. Refer to the Customer Match\npolicy for eligibility\nrequirements and restrictions.\n\nBefore you start: Plan your implementation\n\nBefore you start writing any code, it's important to plan your Customer Match\nimplementation. This section outlines the overall process and key considerations\nto help you design a robust integration. Once you have a clear plan, you can\nproceed with the implementation steps that follow.\n\nUsage flow\n\nHere is the recommended flow for creating and targeting a customer list:\n\n\nCreate an empty customer list.\nCreate an OfflineUserDataJob. It's\nfar more efficient to create a single large job than several\nsmaller jobs.\n\nEnsure that you populate\nthe consent field\nof customer_match_user_list_metadata\nin your OfflineUserDataJob\ncreate requests. For remove requests, consent is not needed. The API\nreturns\nOfflineUserDataJobError.CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS\nif the job's consent.ad_user_data or consent.ad_personalization is set\nto DENIED.\n\nIf a user has denied consent, you could create a job with a\nremove operation to remove the user's identifiers from the user list.\n\nIf you are missing consent for specific users, create a separate job where\nyou don't set the consent field of the job's\ncustomer_match_user_list_metadata, then add identifiers for those users\nusing create operations for that separate job.\nImportant: If consent is missing for\nEEA users, then the consent value is determined as not consented. Data from\nunconsented EEA users won't be processed and cannot be used for ad\npersonalization using Customer Match. See\nFAQs and\nupdates to consent mode\nfor more details.\nAdd operations using the\nOfflineUserDataJobService.AddOfflineUserDataJobOperations\nmethod. We recommend adding up to 10,000 total identifiers in a single call\nfor optimal processing. A single AddOfflineUserDataJobOperations request\ncan contain at most 100,000 identifiers across all of the\nUserData objects in the operations list.\n\nFor example, if each of your UserData objects has one UserIdentifier for\nhashed_email and another UserIdentifier for hashed_phone_number, then\nsendin",
  "fetchedAt": "2025-10-30T21:45:31.610Z"
}